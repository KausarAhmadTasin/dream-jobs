import{getOwnReflectMetadata as e,setReflectMetadata as n,updateOwnReflectMetadata as t}from"@inversifyjs/reflect-metadata-utils";import{getBaseType as i}from"@inversifyjs/prototype-utils";import{stringifyServiceIdentifier as o,LazyServiceIdentifier as r,isPromise as s}from"@inversifyjs/common";const a="@inversifyjs/container/bindingId";function c(){const i=e(Object,a)??0;return i===Number.MAX_SAFE_INTEGER?n(Object,a,Number.MIN_SAFE_INTEGER):t(Object,a,()=>i,e=>e+1),i}const d={Request:"Request",Singleton:"Singleton",Transient:"Transient"},l={ConstantValue:"ConstantValue",DynamicValue:"DynamicValue",Factory:"Factory",Instance:"Instance",Provider:"Provider",ResolvedValue:"ResolvedValue",ServiceRedirection:"ServiceRedirection"};function*u(...e){for(const n of e)yield*n}class p{#e;#n;#t;constructor(e){this.#e=new Map,this.#n={};for(const n of Reflect.ownKeys(e))this.#n[n]=new Map;this.#t=e}add(e,n){this.#i(e).push(n);for(const t of Reflect.ownKeys(n))this.#o(t,n[t]).push(e)}clone(){const e=this.#r(),n=this.#s(),t=Reflect.ownKeys(this.#t),i=this._buildNewInstance(this.#t);this.#a(this.#e,i.#e,e,n);for(const n of t)this.#c(this.#n[n],i.#n[n],e);return i}get(e,n){return this.#n[e].get(n)}getAllKeys(e){return this.#n[e].keys()}removeByRelation(e,n){const t=this.get(e,n);if(void 0===t)return;const i=new Set(t);for(const t of i){const i=this.#e.get(t);if(void 0===i)throw new Error("Expecting model relation, none found");for(const o of i)o[e]===n&&this.#d(t,o);this.#e.delete(t)}}_buildNewInstance(e){return new p(e)}_cloneModel(e){return e}_cloneRelation(e){return e}#r(){const e=new Map;for(const n of this.#e.keys()){const t=this._cloneModel(n);e.set(n,t)}return e}#s(){const e=new Map;for(const n of this.#e.values())for(const t of n){const n=this._cloneRelation(t);e.set(t,n)}return e}#i(e){let n=this.#e.get(e);return void 0===n&&(n=[],this.#e.set(e,n)),n}#o(e,n){let t=this.#n[e].get(n);return void 0===t&&(t=[],this.#n[e].set(n,t)),t}#l(e,n){const t=n.get(e);if(void 0===t)throw new Error("Expecting model to be cloned, none found");return t}#u(e,n){const t=n.get(e);if(void 0===t)throw new Error("Expecting relation to be cloned, none found");return t}#c(e,n,t){for(const[i,o]of e){const e=new Array;for(const n of o)e.push(this.#l(n,t));n.set(i,e)}}#a(e,n,t,i){for(const[o,r]of e){const e=new Array;for(const n of r)e.push(this.#u(n,i));n.set(this.#l(o,t),e)}}#d(e,n){for(const t of Reflect.ownKeys(n))this.#p(e,t,n[t])}#p(e,n,t){const i=this.#n[n].get(t);if(void 0!==i){const o=i.indexOf(e);-1!==o&&i.splice(o,1),0===i.length&&this.#n[n].delete(t)}}}var f,v,g;!function(e){e.moduleId="moduleId",e.serviceId="serviceId"}(f||(f={}));class h{#f;#v;constructor(e,n){this.#f=n??new p({moduleId:{isOptional:!0},serviceId:{isOptional:!1}}),this.#v=e}static build(e){return new h(e)}add(e,n){this.#f.add(e,n)}clone(){return new h(this.#v,this.#f.clone())}get(e){const n=[],t=this.#f.get(f.serviceId,e);void 0!==t&&n.push(t);const i=this.#v()?.get(e);if(void 0!==i&&n.push(i),0!==n.length)return u(...n)}removeAllByModuleId(e){this.#f.removeByRelation(f.moduleId,e)}removeAllByServiceId(e){this.#f.removeByRelation(f.serviceId,e)}}function m(e){return e.isRight?{isRight:!0,value:e.value}:e}function y(e){switch(e.type){case l.ConstantValue:case l.DynamicValue:return function(e){return{cache:m(e.cache),id:e.id,isSatisfiedBy:e.isSatisfiedBy,moduleId:e.moduleId,onActivation:e.onActivation,onDeactivation:e.onDeactivation,scope:e.scope,serviceIdentifier:e.serviceIdentifier,type:e.type,value:e.value}}(e);case l.Factory:return function(e){return{cache:m(e.cache),factory:e.factory,id:e.id,isSatisfiedBy:e.isSatisfiedBy,moduleId:e.moduleId,onActivation:e.onActivation,onDeactivation:e.onDeactivation,scope:e.scope,serviceIdentifier:e.serviceIdentifier,type:e.type}}(e);case l.Instance:return function(e){return{cache:m(e.cache),id:e.id,implementationType:e.implementationType,isSatisfiedBy:e.isSatisfiedBy,moduleId:e.moduleId,onActivation:e.onActivation,onDeactivation:e.onDeactivation,scope:e.scope,serviceIdentifier:e.serviceIdentifier,type:e.type}}(e);case l.Provider:return function(e){return{cache:m(e.cache),id:e.id,isSatisfiedBy:e.isSatisfiedBy,moduleId:e.moduleId,onActivation:e.onActivation,onDeactivation:e.onDeactivation,provider:e.provider,scope:e.scope,serviceIdentifier:e.serviceIdentifier,type:e.type}}(e);case l.ResolvedValue:return function(e){return{cache:m(e.cache),factory:e.factory,id:e.id,isSatisfiedBy:e.isSatisfiedBy,metadata:e.metadata,moduleId:e.moduleId,onActivation:e.onActivation,onDeactivation:e.onDeactivation,scope:e.scope,serviceIdentifier:e.serviceIdentifier,type:e.type}}(e);case l.ServiceRedirection:return function(e){return{id:e.id,isSatisfiedBy:e.isSatisfiedBy,moduleId:e.moduleId,serviceIdentifier:e.serviceIdentifier,targetServiceIdentifier:e.targetServiceIdentifier,type:e.type}}(e)}}!function(e){e.id="id",e.moduleId="moduleId",e.serviceId="serviceId"}(v||(v={}));class M extends p{_buildNewInstance(e){return new M(e)}_cloneModel(e){return y(e)}}class I{#g;#v;constructor(e,n){this.#g=n??new M({id:{isOptional:!1},moduleId:{isOptional:!0},serviceId:{isOptional:!1}}),this.#v=e}static build(e){return new I(e)}clone(){return new I(this.#v,this.#g.clone())}get(e){return this.getNonParentBindings(e)??this.#v()?.get(e)}*getChained(e){const n=this.getNonParentBindings(e);void 0!==n&&(yield*n);const t=this.#v();void 0!==t&&(yield*t.getChained(e))}getBoundServices(){const e=new Set(this.#g.getAllKeys(v.serviceId)),n=this.#v();if(void 0!==n)for(const t of n.getBoundServices())e.add(t);return e}getById(e){return this.#g.get(v.id,e)??this.#v()?.getById(e)}getByModuleId(e){return this.#g.get(v.moduleId,e)??this.#v()?.getByModuleId(e)}getNonParentBindings(e){return this.#g.get(v.serviceId,e)}getNonParentBoundServices(){return this.#g.getAllKeys(v.serviceId)}removeById(e){this.#g.removeByRelation(v.id,e)}removeAllByModuleId(e){this.#g.removeByRelation(v.moduleId,e)}removeAllByServiceId(e){this.#g.removeByRelation(v.serviceId,e)}set(e){const n={[v.id]:e.id,[v.serviceId]:e.serviceIdentifier};void 0!==e.moduleId&&(n[v.moduleId]=e.moduleId),this.#g.add(e,n)}}!function(e){e.moduleId="moduleId",e.serviceId="serviceId"}(g||(g={}));class b{#h;#v;constructor(e,n){this.#h=n??new p({moduleId:{isOptional:!0},serviceId:{isOptional:!1}}),this.#v=e}static build(e){return new b(e)}add(e,n){this.#h.add(e,n)}clone(){return new b(this.#v,this.#h.clone())}get(e){const n=[],t=this.#h.get(g.serviceId,e);void 0!==t&&n.push(t);const i=this.#v()?.get(e);if(void 0!==i&&n.push(i),0!==n.length)return u(...n)}removeAllByModuleId(e){this.#h.removeByRelation(g.moduleId,e)}removeAllByServiceId(e){this.#h.removeByRelation(g.serviceId,e)}}function w(e,n,t,i){const o=Array.isArray(e)?e:[e];if(void 0!==t)if("number"!=typeof t)if(void 0!==i)for(const e of o)e(n,t,i);else Reflect.decorate(o,n.prototype,t);else for(const e of o)e(n,void 0,t);else Reflect.decorate(o,n)}const C="@inversifyjs/core/classMetadataReflectKey";function S(){return{constructorArguments:[],lifecycle:{postConstructMethodName:void 0,preDestroyMethodName:void 0},properties:new Map,scope:void 0}}const N="@inversifyjs/core/pendingClassMetadataCountReflectKey";const P=Symbol.for("@inversifyjs/core/InversifyCoreError");class R extends Error{[P];kind;constructor(e,n,t){super(n,t),this[P]=!0,this.kind=e}static is(e){return"object"==typeof e&&null!==e&&!0===e[P]}static isErrorOfKind(e,n){return R.is(e)&&e.kind===n}}var A,T,x;function j(n){const t=e(n,C)??S();if(!function(n){const t=e(n,N);return void 0!==t&&0!==t}(n))return function(e,n){const t=[];if(n.length<e.length)throw new R(A.missingInjectionDecorator,`Found unexpected missing metadata on type "${e.name}". "${e.name}" constructor requires at least ${e.length.toString()} arguments, found ${n.length.toString()} instead.\nAre you using @inject, @multiInject or @unmanaged decorators in every non optional constructor argument?\n\nIf you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);for(let e=0;e<n.length;++e)void 0===n[e]&&t.push(e);if(t.length>0)throw new R(A.missingInjectionDecorator,`Found unexpected missing metadata on type "${e.name}" at constructor indexes "${t.join('", "')}".\n\nAre you using @inject, @multiInject or @unmanaged decorators at those indexes?\n\nIf you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`)}(n,t.constructorArguments),t;!function(e,n){const t=[];for(let i=0;i<n.constructorArguments.length;++i){const o=n.constructorArguments[i];void 0!==o&&o.kind!==T.unknown||t.push(`  - Missing or incomplete metadata for type "${e.name}" at constructor argument with index ${i.toString()}.\nEvery constructor parameter must be decorated either with @inject, @multiInject or @unmanaged decorator.`)}for(const[i,o]of n.properties)o.kind===T.unknown&&t.push(`  - Missing or incomplete metadata for type "${e.name}" at property "${i.toString()}".\nThis property must be decorated either with @inject or @multiInject decorator.`);if(0===t.length)throw new R(A.unknown,`Unexpected class metadata for type "${e.name}" with uncompletion traces.\nThis might be caused by one of the following reasons:\n\n1. A third party library is targeting inversify reflection metadata.\n2. A bug is causing the issue. Consider submiting an issue to fix it.`);throw new R(A.missingInjectionDecorator,`Invalid class metadata at type ${e.name}:\n\n${t.join("\n\n")}`)}(n,t)}function B(){return 0}function F(e){return n=>{void 0!==n&&n.kind===T.unknown&&t(e,N,B,e=>e-1)}}function k(e,n){return(...t)=>i=>{if(void 0===i)return e(...t);if(i.kind===x.unmanaged)throw new R(A.injectionDecoratorConflict,"Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found");return n(i,...t)}}function $(e){if(e.kind!==T.unknown&&!0!==e.isFromTypescriptParamType)throw new R(A.injectionDecoratorConflict,"Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found")}!function(e){e[e.injectionDecoratorConflict=0]="injectionDecoratorConflict",e[e.missingInjectionDecorator=1]="missingInjectionDecorator",e[e.planning=2]="planning",e[e.resolution=3]="resolution",e[e.unknown=4]="unknown"}(A||(A={})),function(e){e[e.unknown=32]="unknown"}(T||(T={})),function(e){e[e.multipleInjection=0]="multipleInjection",e[e.singleInjection=1]="singleInjection",e[e.unmanaged=2]="unmanaged"}(x||(x={}));const D=k(function(e,n,t){return e===x.multipleInjection?{chained:t?.chained??!1,kind:e,name:void 0,optional:!1,tags:new Map,value:n}:{kind:e,name:void 0,optional:!1,tags:new Map,value:n}},function(e,n,t,i){return $(e),n===x.multipleInjection?{...e,chained:i?.chained??!1,kind:n,value:t}:{...e,kind:n,value:t}});function V(e,n){return t=>{const i=t.properties.get(n);return t.properties.set(n,e(i)),t}}var E;function O(e,n,t,i){if(R.isErrorOfKind(i,A.injectionDecoratorConflict)){const o=function(e,n,t){if(void 0===t){if(void 0===n)throw new R(A.unknown,"Unexpected undefined property and index values");return{kind:E.property,property:n,targetClass:e.constructor}}return"number"==typeof t?{index:t,kind:E.parameter,targetClass:e}:{kind:E.method,method:n,targetClass:e}}(e,n,t);throw new R(A.injectionDecoratorConflict,`Unexpected injection error.\n\nCause:\n\n${i.message}\n\nDetails\n\n${function(e){switch(e.kind){case E.method:return`[class: "${e.targetClass.name}", method: "${e.method.toString()}"]`;case E.parameter:return`[class: "${e.targetClass.name}", index: "${e.index.toString()}"]`;case E.property:return`[class: "${e.targetClass.name}", property: "${e.property.toString()}"]`}}(o)}`,{cause:i})}throw i}function _(e,n){return(i,o,r)=>{try{void 0===r?function(e,n){const i=L(e,n);return(e,n)=>{t(e.constructor,C,S,V(i(e),n))}}(e,n)(i,o):"number"==typeof r?function(e,n){const i=L(e,n);return(e,n,o)=>{if(!function(e,n){return"function"==typeof e&&void 0===n}(e,n))throw new R(A.injectionDecoratorConflict,`Found an @inject decorator in a non constructor parameter.\nFound @inject decorator at method "${n?.toString()??""}" at class "${e.constructor.name}"`);t(e,C,S,function(e,n){return t=>{const i=t.constructorArguments[n];return t.constructorArguments[n]=e(i),t}}(i(e),o))}}(e,n)(i,o,r):function(e,n){const i=L(e,n);return(e,n,o)=>{if(!function(e){return void 0!==e.set}(o))throw new R(A.injectionDecoratorConflict,`Found an @inject decorator in a non setter property method.\nFound @inject decorator at method "${n.toString()}" at class "${e.constructor.name}"`);t(e.constructor,C,S,V(i(e),n))}}(e,n)(i,o,r)}catch(e){O(i,o,r,e)}}}function L(e,n){return t=>{const i=n(t);return n=>(i(n),e(n))}}function z(e){return _(D(x.singleInjection,e),F)}!function(e){e[e.method=0]="method",e[e.parameter=1]="parameter",e[e.property=2]="property"}(E||(E={}));const U="@inversifyjs/core/classIsInjectableFlagReflectKey";const K=[Array,BigInt,Boolean,Function,Number,Object,String];function q(n){const i=e(n,"design:paramtypes");void 0!==i&&t(n,C,S,function(e){return n=>(e.forEach((e,t)=>{var i;void 0!==n.constructorArguments[t]||(i=e,K.includes(i))||(n.constructorArguments[t]=function(e){return{isFromTypescriptParamType:!0,kind:x.singleInjection,name:void 0,optional:!1,tags:new Map,value:e}}(e))}),n)}(i))}function G(i){return o=>{!function(t){if(void 0!==e(t,U))throw new R(A.injectionDecoratorConflict,`Cannot apply @injectable decorator multiple times at class "${t.name}"`);n(t,U,!0)}(o),q(o),void 0!==i&&t(o,C,S,e=>({...e,scope:i}))}}function W(e,n,t){let i;return e.extendConstructorArguments??!0?(i=[...n.constructorArguments],t.constructorArguments.map((e,n)=>{i[n]=e})):i=t.constructorArguments,i}function X(e,n,t){let i;return i=e.extendProperties??!0?new Map(u(n.properties,t.properties)):t.properties,i}function H(e){return n=>{const i=j(e.type);t(n,C,S,function(e,n){const t=t=>({constructorArguments:W(e,n,t),lifecycle:t.lifecycle,properties:X(e,n,t),scope:t.scope});return t}(e,i))}}function J(e){return n=>{const t=i(n);if(void 0===t)throw new R(A.injectionDecoratorConflict,`Expected base type for type "${n.name}", none found.`);H({...e,type:t})(n)}}function Q(e){return n=>{const t=[];let o=i(n);for(;void 0!==o&&o!==Object;){const e=o;t.push(e),o=i(e)}t.reverse();for(const i of t)H({...e,type:i})(n)}}function Y(e,n){return _(D(x.multipleInjection,e,n),F)}function Z(e){return n=>{void 0===n&&t(e,N,B,e=>e+1)}}function ee(e){return n=>{const t=n??{kind:T.unknown,name:void 0,optional:!1,tags:new Map};if(t.kind===x.unmanaged)throw new R(A.injectionDecoratorConflict,"Unexpected injection found. Found @unmanaged injection with additional @named, @optional, @tagged or @targetName injections");return e(t)}}function ne(e){const n=ee(function(e){return n=>{if(void 0!==n.name)throw new R(A.injectionDecoratorConflict,"Unexpected duplicated named decorator");return n.name=e,n}}(e));return _(n,Z)}function te(e){if(e.optional)throw new R(A.injectionDecoratorConflict,"Unexpected duplicated optional decorator");return e.optional=!0,e}function ie(){return _(ee(te),Z)}function oe(){return(e,n,i)=>{try{t(e.constructor,C,S,(o=n,e=>{if(void 0!==e.lifecycle.postConstructMethodName)throw new R(A.injectionDecoratorConflict,"Unexpected duplicated postConstruct decorator");return e.lifecycle.postConstructMethodName=o,e}))}catch(t){O(e,n,void 0,t)}var o}}function re(){return(e,n,i)=>{try{t(e.constructor,C,S,(o=n,e=>{if(void 0!==e.lifecycle.preDestroyMethodName)throw new R(A.injectionDecoratorConflict,"Unexpected duplicated preDestroy decorator");return e.lifecycle.preDestroyMethodName=o,e}))}catch(t){O(e,n,void 0,t)}var o}}function se(e,n){const t=ee(function(e,n){return t=>{if(t.tags.has(e))throw new R(A.injectionDecoratorConflict,"Unexpected duplicated tag decorator with existing tag");return t.tags.set(e,n),t}}(e,n));return _(t,Z)}function ae(){return{kind:x.unmanaged}}const ce=k(ae,function(e){if($(e),function(e){return void 0!==e.name||e.optional||e.tags.size>0}(e))throw new R(A.injectionDecoratorConflict,"Unexpected injection found. Found @unmanaged injection with additional @named, @optional, @tagged or @targetName injections");return ae()});function de(){return _(ce(),F)}var le;function ue(e){if(!(e instanceof Error))return!1;return e instanceof RangeError&&/stack space|call stack|too much recursion/i.test(e.message)||"InternalError"===e.name&&/too much recursion/.test(e.message)}function pe(e,n){if(ue(n)){const t=function(e){const n=[...e];if(0===n.length)return"(No dependency trace)";return n.map(o).join(" -> ")}(function(e){const n=new Set;for(const t of e.servicesBranch){if(n.has(t))return[...n,t];n.add(t)}return[...n]}(e));throw new R(A.planning,`Circular dependency found: ${t}`,{cause:n})}throw n}!function(e){e[e.multipleInjection=0]="multipleInjection",e[e.singleInjection=1]="singleInjection"}(le||(le={}));const fe=Symbol.for("@inversifyjs/core/LazyPlanServiceNode");class ve{[fe];_serviceIdentifier;_serviceNode;constructor(e,n){this[fe]=!0,this._serviceNode=e,this._serviceIdentifier=n}get bindings(){return this._getNode().bindings}get isContextFree(){return this._getNode().isContextFree}get serviceIdentifier(){return this._serviceIdentifier}set bindings(e){this._getNode().bindings=e}set isContextFree(e){this._getNode().isContextFree=e}static is(e){return"object"==typeof e&&null!==e&&!0===e[fe]}invalidate(){this._serviceNode=void 0}isExpanded(){return void 0!==this._serviceNode}_getNode(){return void 0===this._serviceNode&&(this._serviceNode=this._buildPlanServiceNode()),this._serviceNode}}class ge{#m;constructor(e){this.#m=e}get name(){return this.#m.elem.name}get serviceIdentifier(){return this.#m.elem.serviceIdentifier}get tags(){return this.#m.elem.tags}getAncestor(){if(this.#m.elem.getAncestorsCalled=!0,void 0!==this.#m.previous)return new ge(this.#m.previous)}}function he(e,n,t){const i=t?.customServiceIdentifier??n.serviceIdentifier,o=(!0===t?.chained?[...e.operations.getBindingsChained(i)]:[...e.operations.getBindings(i)??[]]).filter(e=>e.isSatisfiedBy(n));if(0===o.length&&void 0!==e.autobindOptions&&"function"==typeof i){const n=function(e,n){const t=j(n),i=t.scope??e.scope;return{cache:{isRight:!1,value:void 0},id:c(),implementationType:n,isSatisfiedBy:()=>!0,moduleId:void 0,onActivation:void 0,onDeactivation:void 0,scope:i,serviceIdentifier:n,type:l.Instance}}(e.autobindOptions,i);e.operations.setBinding(n),o.push(n)}return o}class me{last;constructor(e){this.last=e}concat(e){return new me({elem:e,previous:this.last})}[Symbol.iterator](){let e=this.last;return{next:()=>{if(void 0===e)return{done:!0,value:void 0};const n=e.elem;return e=e.previous,{done:!1,value:n}}}}}function ye(e){const n=new Map;return void 0!==e.rootConstraints.tag&&n.set(e.rootConstraints.tag.key,e.rootConstraints.tag.value),new me({elem:{getAncestorsCalled:!1,name:e.rootConstraints.name,serviceIdentifier:e.rootConstraints.serviceIdentifier,tags:n},previous:void 0})}function Me(e){return void 0!==e.redirections}function Ie(e,n,t,i){const r=t.elem.serviceIdentifier,s=t.previous?.elem.serviceIdentifier;Array.isArray(e)?function(e,n,t,i,r,s){if(0!==e.length){const n=s[s.length-1]??t,a=`Ambiguous bindings found for service: "${o(n)}".${Se(s)}\n\nRegistered bindings:\n\n${e.map(e=>function(e){switch(e.type){case l.Instance:return`[ type: "${e.type}", serviceIdentifier: "${o(e.serviceIdentifier)}", scope: "${e.scope}", implementationType: "${e.implementationType.name}" ]`;case l.ServiceRedirection:return`[ type: "${e.type}", serviceIdentifier: "${o(e.serviceIdentifier)}", redirection: "${o(e.targetServiceIdentifier)}" ]`;default:return`[ type: "${e.type}", serviceIdentifier: "${o(e.serviceIdentifier)}", scope: "${e.scope}" ]`}}(e.binding)).join("\n")}\n\nTrying to resolve bindings for "${we(t,i)}".${Ce(r)}`;throw new R(A.planning,a)}n||be(t,i,r,s)}(e,n,r,s,t.elem,i):function(e,n,t,i,o,r){void 0!==e||n||be(t,i,o,r)}(e,n,r,s,t.elem,i)}function be(e,n,t,i){const r=i[i.length-1]??e,s=`No bindings found for service: "${o(r)}".\n\nTrying to resolve bindings for "${we(e,n)}".${Se(i)}${Ce(t)}`;throw new R(A.planning,s)}function we(e,n){return void 0===n?`${o(e)} (Root service)`:o(n)}function Ce(e){const n=0===e.tags.size?"":`\n- tags:\n  - ${[...e.tags.keys()].map(e=>e.toString()).join("\n  - ")}`;return`\n\nBinding constraints:\n- service identifier: ${o(e.serviceIdentifier)}\n- name: ${e.name?.toString()??"-"}${n}`}function Se(e){return 0===e.length?"":`\n\n- service redirections:\n  - ${e.map(e=>o(e)).join("\n  - ")}`}function Ne(e,n,t,i){if(1===e.redirections.length){const[o]=e.redirections;return void(Me(o)&&Ne(o,n,t,[...i,o.binding.targetServiceIdentifier]))}Ie(e.redirections,n,t,i)}function Pe(e,n,t){if(Array.isArray(e.bindings)&&1===e.bindings.length){const[i]=e.bindings;return void(Me(i)&&Ne(i,n,t,[i.binding.targetServiceIdentifier]))}Ie(e.bindings,n,t,[])}function Re(e){return r.is(e)?e.unwrap():e}function Ae(e){return(n,t,i)=>{const o=Re(i.value),r=t.concat({getAncestorsCalled:!1,name:i.name,serviceIdentifier:o,tags:i.tags}),s=new ge(r.last),a=i.kind===x.multipleInjection&&i.chained,c=he(n,s,{chained:a}),d=[],l={bindings:d,isContextFree:!0,serviceIdentifier:o};if(d.push(...e(n,r,c,l,a)),l.isContextFree=!r.last.elem.getAncestorsCalled,i.kind===x.singleInjection){Pe(l,i.optional,r.last);const[e]=d;l.bindings=e}return l}}function Te(e){return(n,t,i)=>{const o=Re(i.value),r=t.concat({getAncestorsCalled:!1,name:i.name,serviceIdentifier:o,tags:i.tags}),s=new ge(r.last),a=i.kind===le.multipleInjection&&i.chained,c=he(n,s,{chained:a}),d=[],l={bindings:d,isContextFree:!0,serviceIdentifier:o};if(d.push(...e(n,r,c,l,a)),l.isContextFree=!r.last.elem.getAncestorsCalled,i.kind===le.singleInjection){Pe(l,i.optional,r.last);const[e]=d;l.bindings=e}return l}}function xe(e){const n=function(e){return(n,t,i)=>{const o={binding:t,classMetadata:n.operations.getClassMetadata(t.implementationType),constructorParams:[],propertyParams:new Map},r={autobindOptions:n.autobindOptions,node:o,operations:n.operations,servicesBranch:n.servicesBranch};return e(r,i)}}(e),t=function(e){return(n,t,i)=>{const o={binding:t,params:[]},r={autobindOptions:n.autobindOptions,node:o,operations:n.operations,servicesBranch:n.servicesBranch};return e(r,i)}}(e),i=(e,i,r,s,a)=>{const c=Me(s)?s.binding.targetServiceIdentifier:s.serviceIdentifier;e.servicesBranch.push(c);const d=[];for(const s of r)switch(s.type){case l.Instance:d.push(n(e,s,i));break;case l.ResolvedValue:d.push(t(e,s,i));break;case l.ServiceRedirection:{const n=o(e,i,s,a);d.push(n);break}default:d.push({binding:s})}return e.servicesBranch.pop(),d},o=function(e){return(n,t,i,o)=>{const r={binding:i,redirections:[]},s=he(n,new ge(t.last),{chained:o,customServiceIdentifier:i.targetServiceIdentifier});return r.redirections.push(...e(n,t,s,r,o)),r}}(i);return i}function je(e,n,t,i){if(void 0!==e&&(ve.is(t)&&!t.isExpanded()||t.isContextFree)){const i={tree:{root:t}};n.setPlan(e,i)}else n.setNonCachedServiceNode(t,i)}class Be extends ve{#y;#M;#I;#b;constructor(e,n,t,i,o){super(o,Re(i.value)),this.#M=n,this.#y=e,this.#I=t,this.#b=i}_buildPlanServiceNode(){return this.#M(this.#y,this.#I,this.#b)}}class Fe extends ve{#y;#w;#I;#C;constructor(e,n,t,i,o){super(o,Re(i.value)),this.#y=e,this.#w=n,this.#I=t,this.#C=i}_buildPlanServiceNode(){return this.#w(this.#y,this.#I,this.#C)}}function ke(e,n,t,i){const o=function(e,n){const t=function(e,n){return(t,i,o)=>{if(o.kind===x.unmanaged)return;const s=function(e){let n;if(0===e.tags.size)n=void 0;else{if(1!==e.tags.size)return;{const[t,i]=e.tags.entries().next().value;n={key:t,value:i}}}const t=r.is(e.value)?e.value.unwrap():e.value;return e.kind===x.multipleInjection?{chained:e.chained,isMultiple:!0,name:e.name,optional:e.optional,serviceIdentifier:t,tag:n}:{isMultiple:!1,name:e.name,optional:e.optional,serviceIdentifier:t,tag:n}}(o);if(void 0!==s){const e=t.operations.getPlan(s);if(void 0!==e&&e.tree.root.isContextFree)return e.tree.root}const a=n(t,i,o),c=new Be(t,e,i,o,a);return je(s,t.operations,c,{bindingConstraintsList:i,chainedBindings:o.kind===x.multipleInjection&&o.chained,optionalBindings:o.optional}),c}}(e,n);return(e,n,i)=>{const o=n.classMetadata;for(const[r,s]of o.constructorArguments.entries())n.constructorParams[r]=t(e,i,s);for(const[r,s]of o.properties){const o=t(e,i,s);void 0!==o&&n.propertyParams.set(r,o)}return e.node}}(e,t),s=function(e,n){const t=function(e,n){return(t,i,o)=>{const s=function(e){let n;if(0===e.tags.size)n=void 0;else{if(1!==e.tags.size)return;{const[t,i]=e.tags.entries().next().value;n={key:t,value:i}}}const t=r.is(e.value)?e.value.unwrap():e.value;return e.kind===le.multipleInjection?{chained:e.chained,isMultiple:!0,name:e.name,optional:e.optional,serviceIdentifier:t,tag:n}:{isMultiple:!1,name:e.name,optional:e.optional,serviceIdentifier:t,tag:n}}(o);if(void 0!==s){const e=t.operations.getPlan(s);if(void 0!==e&&e.tree.root.isContextFree)return e.tree.root}const a=n(t,i,o),c=new Fe(t,e,i,o,a);return je(s,t.operations,c,{bindingConstraintsList:i,chainedBindings:o.kind===le.multipleInjection&&o.chained,optionalBindings:o.optional}),c}}(e,n);return(e,n,i)=>{const o=n.binding.metadata;for(const[r,s]of o.arguments.entries())n.params[r]=t(e,i,s);return e.node}}(n,i);return(e,n)=>e.node.binding.type===l.Instance?o(e,e.node,n):s(e,e.node,n)}class $e extends ve{#y;constructor(e,n){super(n,n.serviceIdentifier),this.#y=e}_buildPlanServiceNode(){return _e(this.#y)}}const De=Ae(Oe),Ve=Te(Oe),Ee=xe(ke(De,Ve,De,Ve));function Oe(e,n,t,i,o){return Ee(e,n,t,i,o)}const _e=function(e){return n=>{const t=ye(n),i=new ge(t.last),o=n.rootConstraints.isMultiple&&n.rootConstraints.chained,r=he(n,i,{chained:o}),s=[],a={bindings:s,isContextFree:!0,serviceIdentifier:n.rootConstraints.serviceIdentifier};if(s.push(...e(n,t,r,a,o)),a.isContextFree=!t.last.elem.getAncestorsCalled,!n.rootConstraints.isMultiple){Pe(a,n.rootConstraints.isOptional??!1,t.last);const[e]=s;a.bindings=e}return a}}(Ee);function Le(e){try{const n=function(e){return e.rootConstraints.isMultiple?{chained:e.rootConstraints.chained,isMultiple:!0,name:e.rootConstraints.name,optional:e.rootConstraints.isOptional??!1,serviceIdentifier:e.rootConstraints.serviceIdentifier,tag:e.rootConstraints.tag}:{isMultiple:!1,name:e.rootConstraints.name,optional:e.rootConstraints.isOptional??!1,serviceIdentifier:e.rootConstraints.serviceIdentifier,tag:e.rootConstraints.tag}}(e),t=e.operations.getPlan(n);if(void 0!==t)return t;const i=_e(e),o={tree:{root:new $e(e,i)}};return e.operations.setPlan(n,o),o}catch(n){pe(e,n)}}var ze;!function(e){e.bindingAdded="bindingAdded",e.bindingRemoved="bindingRemoved"}(ze||(ze={}));class Ue{#S;#N;#P;constructor(){this.#S=[],this.#N=8,this.#P=1024}*[Symbol.iterator](){let e=0;for(const n of this.#S){const t=n.deref();void 0===t?++e:yield t}this.#S.length>=this.#N&&this.#R(e)&&this.#A(e)}push(e){const n=new WeakRef(e);if(this.#S.push(n),this.#S.length>=this.#N&&this.#S.length%this.#P===0){let e=0;for(const n of this.#S)void 0===n.deref()&&++e;this.#R(e)&&this.#A(e)}}#A(e){const n=new Array(this.#S.length-e);let t=0;for(const e of this.#S)e.deref()&&(n[t++]=e);this.#S=n}#R(e){return e>=.5*this.#S.length}}const Ke=xe(ke(De,Ve,function(e,n,t){return qe(e,n,t)},function(e,n,t){return Ge(e,n,t)})),qe=function(e){const n=Ae(e);return(e,t,i)=>{try{return n(e,t,i)}catch(e){if(R.isErrorOfKind(e,A.planning))return;throw e}}}(Ke),Ge=function(e){const n=Te(e);return(e,t,i)=>{try{return n(e,t,i)}catch(e){if(R.isErrorOfKind(e,A.planning))return;throw e}}}(Ke);function We(e,n,t,i,o){if(ve.is(n)&&!n.isExpanded())return{isContextFreeBinding:!0,shouldInvalidateServiceNode:!1};const r=new ge(i.last);return!t.isSatisfiedBy(r)||i.last.elem.getAncestorsCalled?{isContextFreeBinding:!i.last.elem.getAncestorsCalled,shouldInvalidateServiceNode:!1}:function(e,n,t,i,o){let r;try{[r]=Ke(e,i,[t],n,o)}catch(e){if(ue(e))return{isContextFreeBinding:!1,shouldInvalidateServiceNode:!0};throw e}return function(e,n){if(Array.isArray(e.bindings))e.bindings.push(n);else{if(void 0!==e.bindings){if(!ve.is(e))throw new R(A.planning,"Unexpected non-lazy plan service node. This is likely a bug in the planning logic. Please, report this issue");return{isContextFreeBinding:!0,shouldInvalidateServiceNode:!0}}e.bindings=n}return{isContextFreeBinding:!0,shouldInvalidateServiceNode:!1}}(n,r)}(e,n,t,i,o)}function Xe(e,n,t,i){if(ve.is(e)&&!e.isExpanded())return{bindingNodeRemoved:void 0,isContextFreeBinding:!0};const o=new ge(t.last);if(!n.isSatisfiedBy(o)||t.last.elem.getAncestorsCalled)return{bindingNodeRemoved:void 0,isContextFreeBinding:!t.last.elem.getAncestorsCalled};let r;if(Array.isArray(e.bindings))e.bindings=e.bindings.filter(e=>e.binding!==n||(r=e,!1));else if(e.bindings?.binding===n)if(r=e.bindings,i)e.bindings=void 0;else{if(!ve.is(e))throw new R(A.planning,"Unexpected non-lazy plan service node. This is likely a bug in the planning logic. Please, report this issue");e.invalidate()}return{bindingNodeRemoved:r,isContextFreeBinding:!0}}class He{#T;#x;#j;#B;#F;#k;constructor(){this.#T=new Map,this.#x=this.#$(),this.#j=this.#$(),this.#B=this.#$(),this.#F=this.#$(),this.#k=new Ue}clearCache(){for(const e of this.#D())e.clear();for(const e of this.#k)e.clearCache()}get(e){return void 0===e.name?void 0===e.tag?this.#V(this.#x,e).get(e.serviceIdentifier):this.#V(this.#F,e).get(e.serviceIdentifier)?.get(e.tag.key)?.get(e.tag.value):void 0===e.tag?this.#V(this.#j,e).get(e.serviceIdentifier)?.get(e.name):this.#V(this.#B,e).get(e.serviceIdentifier)?.get(e.name)?.get(e.tag.key)?.get(e.tag.value)}invalidateServiceBinding(e){this.#E(e),this.#O(e),this.#_(e),this.#L(e),this.#z(e);for(const n of this.#k)n.invalidateServiceBinding(e)}set(e,n){void 0===e.name?void 0===e.tag?this.#V(this.#x,e).set(e.serviceIdentifier,n):this.#U(this.#U(this.#V(this.#F,e),e.serviceIdentifier),e.tag.key).set(e.tag.value,n):void 0===e.tag?this.#U(this.#V(this.#j,e),e.serviceIdentifier).set(e.name,n):this.#U(this.#U(this.#U(this.#V(this.#B,e),e.serviceIdentifier),e.name),e.tag.key).set(e.tag.value,n)}setNonCachedServiceNode(e,n){let t=this.#T.get(e.serviceIdentifier);void 0===t&&(t=new Map,this.#T.set(e.serviceIdentifier,t)),t.set(e,n)}subscribe(e){this.#k.push(e)}#$(){const e=new Array(8);for(let n=0;n<e.length;++n)e[n]=new Map;return e}#K(e,n,t,i){const o=!!(2&n);let r;if(o){r={chained:!!(0&n),isMultiple:o,serviceIdentifier:e.binding.serviceIdentifier}}else r={isMultiple:o,serviceIdentifier:e.binding.serviceIdentifier};return!!(1&n)&&(r.isOptional=!0),void 0!==t&&(r.name=t),void 0!==i&&(r.tag=i),{autobindOptions:void 0,operations:e.operations,rootConstraints:r,servicesBranch:[]}}#U(e,n){let t=e.get(n);return void 0===t&&(t=new Map,e.set(n,t)),t}#V(e,n){return e[this.#q(n)]}#D(){return[this.#T,...this.#x,...this.#j,...this.#B,...this.#F]}#q(e){return e.isMultiple?(e.chained?4:0)|(e.optional?1:0)|2:e.optional?1:0}#O(e){for(const[n,t]of this.#j.entries()){const i=t.get(e.binding.serviceIdentifier);if(void 0!==i)for(const[t,o]of i.entries())this.#G(e,o,n,t,void 0)}}#_(e){for(const[n,t]of this.#B.entries()){const i=t.get(e.binding.serviceIdentifier);if(void 0!==i)for(const[t,o]of i.entries())for(const[i,r]of o.entries())for(const[o,s]of r.entries())this.#G(e,s,n,t,{key:i,value:o})}}#W(e){switch(e.binding.type){case l.ServiceRedirection:for(const n of e.redirections)this.#W(n);break;case l.Instance:for(const n of e.constructorParams)void 0!==n&&this.#X(n);for(const n of e.propertyParams.values())this.#X(n);break;case l.ResolvedValue:for(const n of e.params)this.#X(n)}}#X(e){const n=this.#T.get(e.serviceIdentifier);void 0!==n&&n.has(e)&&(n.delete(e),this.#H(e))}#H(e){if((!ve.is(e)||e.isExpanded())&&void 0!==e.bindings)if(Array.isArray(e.bindings))for(const n of e.bindings)this.#W(n);else this.#W(e.bindings)}#z(e){const n=this.#T.get(e.binding.serviceIdentifier);if(void 0!==n)switch(e.kind){case ze.bindingAdded:for(const[t,i]of n){const n=We({autobindOptions:void 0,operations:e.operations,servicesBranch:[]},t,e.binding,i.bindingConstraintsList,i.chainedBindings);n.isContextFreeBinding?n.shouldInvalidateServiceNode&&ve.is(t)&&(this.#H(t),t.invalidate()):this.clearCache()}break;case ze.bindingRemoved:for(const[t,i]of n){const n=Xe(t,e.binding,i.bindingConstraintsList,i.optionalBindings);n.isContextFreeBinding?void 0!==n.bindingNodeRemoved&&this.#W(n.bindingNodeRemoved):this.clearCache()}}}#E(e){for(const[n,t]of this.#x.entries()){const i=t.get(e.binding.serviceIdentifier);this.#G(e,i,n,void 0,void 0)}}#L(e){for(const[n,t]of this.#F.entries()){const i=t.get(e.binding.serviceIdentifier);if(void 0!==i)for(const[t,o]of i.entries())for(const[i,r]of o.entries())this.#G(e,r,n,void 0,{key:t,value:i})}}#G(e,n,t,i,o){if(void 0!==n&&ve.is(n.tree.root)){const c=this.#K(e,t,i,o);switch(e.kind){case ze.bindingAdded:{const t=(r=c,s=n.tree.root,a=e.binding,ve.is(s)&&!s.isExpanded()?{isContextFreeBinding:!0,shouldInvalidateServiceNode:!1}:We(r,s,a,ye(r),r.rootConstraints.isMultiple&&r.rootConstraints.chained));t.isContextFreeBinding?t.shouldInvalidateServiceNode&&(this.#H(n.tree.root),n.tree.root.invalidate()):this.clearCache()}break;case ze.bindingRemoved:{const t=function(e,n,t){return ve.is(n)&&!n.isExpanded()?{bindingNodeRemoved:void 0,isContextFreeBinding:!0}:Xe(n,t,ye(e),e.rootConstraints.isOptional??!1)}(c,n.tree.root,e.binding);t.isContextFreeBinding?void 0!==t.bindingNodeRemoved&&this.#W(t.bindingNodeRemoved):this.clearCache()}}}var r,s,a}}function Je(e,n){if(ue(n)){const t=function(e){const n=[...e];if(0===n.length)return"(No dependency trace)";return n.map(o).join(" -> ")}(function(e){const n=e.planResult.tree.root,t=[];function i(e){const n=t.indexOf(e);if(-1!==n){return[...t.slice(n),e].map(e=>e.serviceIdentifier)}t.push(e);try{for(const n of function(e){const n=[],t=e.bindings;if(void 0===t)return n;const i=e=>{if(Me(e))for(const n of e.redirections)i(n);else switch(e.binding.type){case l.Instance:{const t=e;for(const e of t.constructorParams)void 0!==e&&n.push(e);for(const e of t.propertyParams.values())n.push(e);break}case l.ResolvedValue:{const t=e;for(const e of t.params)n.push(e);break}}};if(Array.isArray(t))for(const e of t)i(e);else i(t);return n}(e)){const e=i(n);if(void 0!==e)return e}}finally{t.pop()}}return i(n)??[]}(e));throw new R(A.planning,`Circular dependency found: ${t}`,{cause:n})}throw n}function Qe(e,n){return s(n)?(e.cache={isRight:!0,value:n},n.then(n=>Ye(e,n))):Ye(e,n)}function Ye(e,n){return e.cache={isRight:!0,value:n},n}function Ze(e,n,t){const i=e.getActivations(n);return void 0===i?t:s(t)?en(e,t,i[Symbol.iterator]()):function(e,n,t){let i=n,o=t.next();for(;!0!==o.done;){const n=o.value(e.context,i);if(s(n))return en(e,n,t);i=n,o=t.next()}return i}(e,t,i[Symbol.iterator]())}async function en(e,n,t){let i=await n,o=t.next();for(;!0!==o.done;)i=await o.value(e.context,i),o=t.next();return i}function nn(e,n,t){let i=t;if(void 0!==n.onActivation){const t=n.onActivation;i=s(i)?i.then(n=>t(e.context,n)):t(e.context,i)}return Ze(e,n.serviceIdentifier,i)}function tn(e){return(n,t)=>{if(t.cache.isRight)return t.cache.value;return Qe(t,nn(n,t,e(n,t)))}}const on=tn(function(e,n){return n.value});function rn(e){return e}function sn(e,n){return(t,i)=>{const o=e(i);switch(o.scope){case d.Singleton:if(o.cache.isRight)return o.cache.value;return Qe(o,nn(t,o,n(t,i)));case d.Request:{if(t.requestScopeCache.has(o.id))return t.requestScopeCache.get(o.id);const e=nn(t,o,n(t,i));return t.requestScopeCache.set(o.id,e),e}case d.Transient:return nn(t,o,n(t,i))}}}const an=(e=>sn(rn,e))(function(e,n){return n.value(e.context)});const cn=tn(function(e,n){return n.factory(e.context)});function dn(e,n,t){const i=function(e,n,t){if(void 0===t)return;if(!(t in e))throw new R(A.resolution,`Expecting a "${t.toString()}" property when resolving "${n.implementationType.name}" class @postConstruct decorated method, none found.`);if("function"!=typeof e[t])throw new R(A.resolution,`Expecting a "${t.toString()}" method when resolving "${n.implementationType.name}" class @postConstruct decorated method, a non function property was found instead.`);{let i;try{i=e[t]()}catch(e){throw new R(A.resolution,`Unexpected error found when calling "${t.toString()}" @postConstruct decorated method on class "${n.implementationType.name}"`,{cause:e})}if(s(i))return async function(e,n,t){try{await t}catch(t){throw new R(A.resolution,`Unexpected error found when calling "${n.toString()}" @postConstruct decorated method on class "${e.implementationType.name}"`,{cause:t})}}(n,t,i)}}(e,n,t);return s(i)?i.then(()=>e):e}function ln(e){return(n,t,i)=>{const o=new i.binding.implementationType(...n),r=e(t,o,i);return s(r)?r.then(()=>dn(o,i.binding,i.classMetadata.lifecycle.postConstructMethodName)):dn(o,i.binding,i.classMetadata.lifecycle.postConstructMethodName)}}const un=tn(function(e,n){return n.provider(e.context)});function pn(e){return e.binding}function fn(e){return e.binding}const vn=function(e){return(n,t,i)=>{const o=[];for(const[r,a]of i.propertyParams){const c=i.classMetadata.properties.get(r);if(void 0===c)throw new R(A.resolution,`Expecting metadata at property "${r.toString()}", none found`);c.kind!==x.unmanaged&&void 0!==a.bindings&&(t[r]=e(n,a),s(t[r])&&o.push((async()=>{t[r]=await t[r]})()))}if(o.length>0)return Promise.all(o).then(()=>{})}}(wn),gn=function(e){return function n(t,i){const o=[];for(const r of i.redirections)Me(r)?o.push(...n(t,r)):o.push(e(t,r));return o}}(bn),hn=function(e,n,t){return(i,o)=>{const r=e(i,o);return s(r)?n(r,i,o):t(r,i,o)}}(function(e){return(n,t)=>{const i=[];for(const o of t.constructorParams)void 0===o?i.push(void 0):i.push(e(n,o));return i.some(s)?Promise.all(i):i}}(wn),function(e){return async(n,t,i)=>{const o=await n;return e(o,t,i)}}(ln(vn)),ln(vn)),mn=function(e){return(n,t)=>{const i=e(n,t);return s(i)?i.then(e=>t.binding.factory(...e)):t.binding.factory(...i)}}(function(e){return(n,t)=>{const i=[];for(const o of t.params)i.push(e(n,o));return i.some(s)?Promise.all(i):i}}(wn)),yn=(e=>sn(pn,e))(hn),Mn=(e=>sn(fn,e))(mn);function In(e){try{return wn(e,e.planResult.tree.root)}catch(n){Je(e,n)}}function bn(e,n){switch(n.binding.type){case l.ConstantValue:return on(e,n.binding);case l.DynamicValue:return an(e,n.binding);case l.Factory:return cn(e,n.binding);case l.Instance:return yn(e,n);case l.Provider:return un(e,n.binding);case l.ResolvedValue:return Mn(e,n)}}function wn(e,n){if(void 0!==n.bindings)return Array.isArray(n.bindings)?function(e,n){const t=[];for(const i of n)Me(i)?t.push(...gn(e,i)):t.push(bn(e,i));if(t.some(s))return Promise.all(t);return t}(e,n.bindings):function(e,n){if(Me(n)){const t=gn(e,n);if(1===t.length)return t[0];throw new R(A.resolution,"Unexpected multiple resolved values on single injection")}return bn(e,n)}(e,n.bindings)}function Cn(e){return void 0!==e.scope}function Sn(e,n){if(void 0!==e.lifecycle.preDestroyMethodName&&"function"==typeof n[e.lifecycle.preDestroyMethodName])return n[e.lifecycle.preDestroyMethodName]()}function Nn(e,n,t){const i=e.getDeactivations(n);if(void 0!==i)return s(t)?Pn(t,i[Symbol.iterator]()):function(e,n){let t=n.next();for(;!0!==t.done;){const i=t.value(e);if(s(i))return Pn(e,n);t=n.next()}}(t,i[Symbol.iterator]())}async function Pn(e,n){const t=await e;let i=n.next();for(;!0!==i.done;)await i.value(t),i=n.next()}function Rn(e,n){const t=function(e,n){if(n.type===l.Instance){const t=e.getClassMetadata(n.implementationType),i=n.cache.value;return s(i)?i.then(e=>Sn(t,e)):Sn(t,i)}}(e,n);return void 0===t?An(e,n):t.then(()=>An(e,n))}function An(e,n){const t=n.cache;return s(t.value)?t.value.then(t=>Tn(e,n,t)):Tn(e,n,t.value)}function Tn(e,n,t){let i;if(void 0!==n.onDeactivation){i=(0,n.onDeactivation)(t)}return void 0===i?Nn(e,n.serviceIdentifier,t):i.then(()=>Nn(e,n.serviceIdentifier,t))}function xn(e,n){if(void 0===n)return;const t=function(e){const n=[];for(const t of e)Cn(t)&&t.scope===d.Singleton&&t.cache.isRight&&n.push(t);return n}(n),i=[];for(const n of t){const t=Rn(e,n);void 0!==t&&i.push(t)}return i.length>0?Promise.all(i).then(()=>{}):void 0}function jn(e,n){const t=e.getBindingsFromModule(n);return xn(e,t)}function Bn(e,n){const t=e.getBindings(n);return xn(e,t)}export{h as ActivationsService,I as BindingService,ze as CacheBindingInvalidationKind,x as ClassElementMetadataKind,b as DeactivationsService,He as PlanResultCacheService,le as ResolvedValueElementMetadataKind,d as bindingScopeValues,l as bindingTypeValues,w as decorate,c as getBindingId,j as getClassMetadata,z as inject,J as injectFromBase,Q as injectFromHierarchy,G as injectable,Y as multiInject,ne as named,ie as optional,Le as plan,oe as postConstruct,re as preDestroy,In as resolve,xn as resolveBindingsDeactivations,jn as resolveModuleDeactivations,Bn as resolveServiceDeactivations,se as tagged,de as unmanaged};
//# sourceMappingURL=index.js.map
